---
layout: post
title: 운영체제 Three Easy Pieces Ch.6
---

### 제 6 장 제한적 직접 실행 원리 (Limited Direct Execution)

##### 서론

- CPU 가상화를 위해 해결 해야 할 문제점
  1. 성능 저하
  2. 제어 문제
- 운영체제가 제어권을 유지하면서 성능 저하가 없도록 하는 것이 필수적

##### 6.1 기본 원리: 제한적 직접 실행

- 프로그램을 CPU에서 직접 실행시키도록 하는 것
- 사용자 프로그램이 원치 않는 일을 하지 않는 것을 보장할 수 없으며, 프로그램의 실행을 중단하고 다른 프로세스로 전환시킬 수 있는 방법에 대한 고민이 필요

##### 6.2 문제점 1 : 제한된 연산

- 직접 실행하는 경우, 빠르게 실행된다는 장점이 있으나, 프로세스가 입출력 연산 등 방치하면 문제가 생길 수 있는 연산들을 모두 수행할 수 있게 된다는 문제가 있음

  > 보안을 위해 사용자의 입력 유효성 검사를 세심하게 할 필요가 있다

  - **User Mode**, **Kernel Mode**가 도입되어 **Trap** 명령어와 **Return From Trap** 명령어를 통해 mode를 지속적으로 전환함
  - 전환시에 몇몇 플래그와 레지스터의 값들을 Kernel Stack에 저장

- Kernel은 부팅 시에 **Trap Table**(트랩 테이블)을 만들고, 이를 통해 시스템을 통제함

- 운영체제는 Trap Table에서 특정 상황에 맞는 **Trap Handler의 위치**를 찾아 하드웨어에게 알려주어 하드웨어가 어떤 일을 수행해야 하는지 알려줌

##### 6.3 문제점 2: 프로세스 간 전환

- 직접 실행에서 프로세스 전환이 가능해야 하지만 이는 까다로운 문제임

- **Cooperative Approach(협조 방식)**: System Call 호출까지 대기

  - 실행 중인 프로세스가 System Call을 호출할 때까지 대기하는 수동적인 방식
  - 무한 Loop 등에 갇혔을 때 운영체제가 제어권을 얻을 수 있는 방법이 없음

- **Non - Cooperative Approach(비협조 방식)**: 운영체제가 제어권 확보

  > 협조방식에서 System Call 없이 제어권을 획득하려면 재부팅하는 수 밖에 없다

  - 일정 시간마다 **Timer Interrupt**를 발생시켜 Interrupt Handler가 운영체제에 의해 처리 되도록하여 운영체제의 제어권을 확보

  > 재부팅은 오래되었거나 유출된 자원을 시스템에 반환하는 검증된 방법이다

- 문맥의 저장과 복원

  - 운영체제는 현재 실행 중인 프로세스를 계속 실행할지, 다른 프로세스를 실행할지 중요한 결정을 내려야 하는데, 이는 운영체제의 Scheduler를 사용함
  - 다른 프로세스로 전환되기로 결정하면, 운영체제는 **Context Switch**라 불리는 코드를 실행함
  - A프로세스에서 B프로세스로 전환시, A프로세스의 레지스터 값들을 Kernel Stack에 저장하고 A의 프로세스 구조체에 저장한 뒤, B의 프로세스 구조체에 저장되어 있던 레지스터 값들을 복원한 뒤 Stack Pointer Register 값을 B의 Kernel Stack으로 바꿈

##### 6.4 병행 실행으로 인한 문제

- 동시에 여러 Interrupt가 발생하면, 운영체제가 이를 처리하기 어려워짐
  - 하나의 Interrupt를 처리하는 동안에는 다른 Interrupt가 발생하지 못하도록 불능화 시키는 방법이 있음
    - 손실되는 Interrupt가 생기게 됨
  - 다양한 Lock 기법을 통해 다수의 작업을 동시에 진행시킴
    - 많은 문제점과 버그가 발생함

##### 6.5 요약

- 운영체제는 CPU를 Baby Proofing과 유사하게 보호하게 됨